var documenterSearchIndex = {"docs":
[{"location":"sho/#Complete-Example:-The-Harmonic-Oscillator","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"","category":"section"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"We will now turn away from general relativity and use QuasinormalModes.jl to compute to compute the energy eigenvalues of the quantum harmonic oscillator following this paper.","category":"page"},{"location":"sho/#Mathematical-preliminaries","page":"Complete Example: The Harmonic Oscillator","title":"Mathematical preliminaries","text":"","category":"section"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"If we measure the energy of the system in units of hbaromega and distance in units of sqrthbar(momega) the time independent Schrödinger equation for the quantum harmonic oscillator is written as","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"-psi^primeprime(x) + x^2psi(x) = epsilonpsi(x)","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"where we defined epsilon equiv 2 E and E is the quantum state's energy. Imposing that psi(x) decays like a Gaussian distribution asymptotically, we apply the ansatz","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"psi(x) = e^-x^22f(x)","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"which, substituting in the original equation, yields","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"f^primeprime(x) = 2 x f^prime(x) + (1-epsilon)f(x)","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"This allows us to easily identify lambda_0 = 2x and s_0 = 1 - epsilon. In all our implementations we shall refer the sought eigenvalue epsilon using the variable ω in order to maintain consistency with the previous example.","category":"page"},{"location":"sho/#Implementing-the-master-equation-as-an-analytic-problem","page":"Complete Example: The Harmonic Oscillator","title":"Implementing the master equation as an analytic problem","text":"","category":"section"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"The first step is to load the required packages to run this example: QuasinormalModes and SymEngine:","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"using QuasinormalModes\nusing SymEngine","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"Next, we create a parametric type that sub-types AnalyticAIMProblem. As the eigenvalue in the master equation is a quadratic polynomial, we will sub-type QuadraticEigenvalueProblem with the following structure:","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"struct HarmonicOscilatorData{N,T} <: QuadraticEigenvalueProblem{N,T}\n    nIter::N\n    x0::T\n\n    vars::Tuple{Basic, Basic}\n    exprs::Tuple{Basic, Basic}\nend","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"Now we implement the constructor and extend the default implementations:","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"function HarmonicOscilatorData(nIter::N, x0::T) where {N,T}\n\t\n    vars = @vars x ω\n\n    λ0 = 2*x\n    S0 = 1 - ω\n\n    return HarmonicOscilatorData{N,T}(nIter, x0, vars, (λ0, S0))\nend\n\nQuasinormalModes.λ0(d::HarmonicOscilatorData{N,T}) where {N,T} = d.exprs[1]\nQuasinormalModes.S0(d::HarmonicOscilatorData{N,T}) where {N,T}  = d.exprs[2]\n\nQuasinormalModes.get_niter(d::HarmonicOscilatorData{N,T}) where {N,T} = d.nIter\nQuasinormalModes.get_x0(d::HarmonicOscilatorData{N,T}) where {N,T} = d.x0\n\nQuasinormalModes.get_ODEvar(d::HarmonicOscilatorData{N,T}) where {N,T} = d.vars[1]\nQuasinormalModes.get_ODEeigen(d::HarmonicOscilatorData{N,T}) where {N,T} = d.vars[2]","category":"page"},{"location":"sho/#Implementing-the-master-equation-as-a-numeric-problem","page":"Complete Example: The Harmonic Oscillator","title":"Implementing the master equation as a numeric problem","text":"","category":"section"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"The structure, constructor and extensions are","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"struct NHarmonicOscilatorData{N,T} <: NumericAIMProblem{N,T}\n    nIter::N\n    x0::T\nend\n\nfunction NHarmonicOscilatorData(nIter::N, x0::T) where {N,T}\n    return NHarmonicOscilatorData{N,T}(nIter, x0)\nend\n\nQuasinormalModes.λ0(::NHarmonicOscilatorData{N,T}) where {N,T} = (x,ω) -> 2*x\nQuasinormalModes.S0(::NHarmonicOscilatorData{N,T}) where {N,T} = (x,ω) -> 1 - ω + x - x\n\nQuasinormalModes.get_niter(d::NHarmonicOscilatorData{N,T}) where {N,T} = d.nIter\nQuasinormalModes.get_x0(d::NHarmonicOscilatorData{N,T}) where {N,T} = d.x0","category":"page"},{"location":"sho/#Constructing-problems-and-initializing-the-cache","page":"Complete Example: The Harmonic Oscillator","title":"Constructing problems and initializing the cache","text":"","category":"section"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"Once again, we create our problems and cache objects by calling the constructors:","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"p_ana = HarmonicOscilatorData(0x0000A, 0.5);\np_num = NHarmonicOscilatorData(0x0000A, 0.5);\n\nc_ana = AIMCache(p_ana)\nc_num = AIMCache(p_num)","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"Here we are setting up problems to be solved using 10 iterations with x0 = 0.5","category":"page"},{"location":"sho/#Computing-the-eigenvalues","page":"Complete Example: The Harmonic Oscillator","title":"Computing the eigenvalues","text":"","category":"section"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"Once again we compute the eigenvalues by calling","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"ev_ana = computeEigenvalues(Serial(), p_ana, c_ana)\nev_num = eigenvaluesInGrid(Serial(), p_num, c_num, (0.0, 21.0))","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"The results are two arrays, containing the eigenvalues. As before, we define a function to print the results to stdout","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"function printEigen(eigenvalues)\n    println(\"--------------------------------------\")\n\n    for i in eachindex(eigenvalues)\n        println(\"n = $i, ω = $(eigenvalues[i])\")\n    end\n    \n    println(\"--------------------------------------\")\n\n    return nothing\nend\n\nprintln(\"Analytic results\")\nprintEigen(reverse!(ev_ana))\n\nprintln(\"Numeric results\")\nprintEigen(ev_num)","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"The complete source file for this example can be found in harmonic_oscillator.jl. The output is agreement with the expected result for the eigenenergies of the harmonic oscillator, that is, E_n = n + 12","category":"page"},{"location":"sho/","page":"Complete Example: The Harmonic Oscillator","title":"Complete Example: The Harmonic Oscillator","text":"Analytic results\n--------------------------------------\nn = 1, ω = 0.9999999999999999 + 0.0im\nn = 2, ω = 2.9999999999999964 + 0.0im\nn = 3, ω = 4.999999999999426 + 0.0im\nn = 4, ω = 7.000000000006788 + 0.0im\nn = 5, ω = 8.999999999980533 + 0.0im\nn = 6, ω = 10.999999804542819 + 0.0im\nn = 7, ω = 13.000000959453153 + 0.0im\nn = 8, ω = 14.999998108295404 + 0.0im\nn = 9, ω = 17.00000187312756 + 0.0im\nn = 10, ω = 18.999999068409203 - 0.0im\nn = 11, ω = 21.000000186185098 + 0.0im\n--------------------------------------\nNumeric results\n--------------------------------------\nn = 1, ω = 1.0\nn = 2, ω = 3.000000000000006\nn = 3, ω = 5.000000000000002\nn = 4, ω = 7.000000000000006\nn = 5, ω = 8.999999999999988\nn = 6, ω = 11.0\nn = 7, ω = 12.999999999999977\nn = 8, ω = 15.000000000000014\nn = 9, ω = 16.999999999999908\nn = 10, ω = 19.000000000000025\nn = 11, ω = 21.0\n--------------------------------------","category":"page"},{"location":"org/#Package-organization","page":"Package organization","title":"Package organization","text":"","category":"section"},{"location":"org/#A-Brief-description-of-the-AIM","page":"Package organization","title":"A Brief description of the AIM","text":"","category":"section"},{"location":"org/","page":"Package organization","title":"Package organization","text":"QuasinormalModes.jl is in it's core an implementation of the Asymptotic Iteration Method. For a complete description of the general method the reader is encouraged to read this paper. Our implementation is based on the variation of the method described in this paper. The method requires 3 basic steps:","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"Incorporate the asymptotic boundary conditions into the ODE.\nCompactify the domain of the problem (if it isn't already compact).\nWrite the ODE in the form y^primeprime(x) = lambda_0(x)y^prime(x) + s_0(x)y(x)","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"From the ODE coefficients lambda_0(x) and s_0(x) the AIM computes the eigenvalues by requiring that the \"quantization condition\"","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"delta_n = s_nlambda_n-1 - s_n-1lambda_n = 0","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"is satisfied, where","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"lambda_n = lambda^prime_n-1 + s_n-1 + lambda_0 lambda_n-1","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"and","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"s_n = s^prime_n-1 + s_0 s_n-1","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"QuasinormalModes.jl expects as input the lambda_0(x) and s_0(x) coefficients computed with the 3 steps described above. This documentation contains two practical examples of how to obtain and feed such coefficients to the package.","category":"page"},{"location":"org/#The-type-hierarchy","page":"Package organization","title":"The type hierarchy","text":"","category":"section"},{"location":"org/","page":"Package organization","title":"Package organization","text":"QuasinormalModes.jl employs two main strategies in order to find eigenvalues using the AIM: problems can be solved in a semi-analytic or purely numeric fashion. We make use of Julia's type system in order to implement structures that reflect these operation modes. All of the package's exported functionality is designed to operate on sub-types of abstract types that reflect the desired solution strategy (semi-analytic or numeric). The user is responsible for constructing concrete types that are sub-types of the exported abstract types with the actual problem specific information. It's thus usefully to start by inspecting the package's exported type hierarchy:","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"<table border=\"0\"><tr>\n<td>\n\t<figure>\n\t\t<img src='../assets/types.svg' alt='missing'><br>\n\t\t<figcaption><em>QuasinormalModes.jl type hierarchy</em></figcaption>\n\t</figure>\n</td>\n</tr></table>","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"AIMProblem is the parent type of all problems that can be solved with this package. All problems must be sub-type it and a user can use it to construct functions that operate on all AIM solvable problems.\nNumericAIMProblem is the parent type of all problems that can be solved using a numeric approach.\nAnalyticAIMProlem is the parent type of all problems that can be solved using a semi-analytic approach.\nQuadraticEigenvaluePoblem is a specific type of analytic problem whose eigenvalues appear in the ODE as a (possibly incomplete) quadratic polynomial.","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"All types are parameterized by two parameters: N <: Unsigned and T <: Number which represent respectively, the type used to represent the number of iterations the AIM will perform and the type used in the numeric computations of the method.","category":"page"},{"location":"org/#Type-traits","page":"Package organization","title":"Type traits","text":"","category":"section"},{"location":"org/","page":"Package organization","title":"Package organization","text":"Type traits are non-exported abstract types that help the user to ensure that their sub-types implement the correct functions. Currently there is only one defined trait, called AnalyticityTrait. This trait can have two possible \"values\": IsAnalytic and IsNumeric, that are represented by concrete types. The default trait of an AIMProblem is IsNumeric, while any sub-type of AnalyticAIMProblem has the IsAnalytic and NumericAIMProblem have the IsNumeric trait","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"With these traits, we enforce that the user must implement for all problem types, the following functions:","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"λ0: Return the λ0 component of the ODE. The actual implementation depends heavily on the problem type.\nS0: Return the S0 component of the ODE. The actual implementation depends heavily on the problem type.\nget_niter: Return the number of iterations that the AIM will perform.\nget_x0: Return the expansion point of the AIM.","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"For problems with the IsAnalytic trait, the user must implement the following functions function:","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"get_ODEvar which returns an object that represents the ODE's variable.\nget_ODEeigen which returns an object that represents the ODE's eigenvalue.","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"Failure to implement these functions returns an error with the appropriate message. Note that these traits only check that such functions are implemented for a certain problem type and not that they follow a particular implementation pattern. The contract on the functions implementations is soft and will be clarified further on. Failure to abide by these soft contracts results in undefined behavior.","category":"page"},{"location":"org/#Extending-the-default-functionality","page":"Package organization","title":"Extending the default functionality","text":"","category":"section"},{"location":"org/","page":"Package organization","title":"Package organization","text":"The following assumes that the package SymEngine is installed. If a problem type P{N,T} is a sub-type of AnalyticAIMProblem{N,T}, the user must extend the default implementations abiding by the following rules","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"QuasinormalModes.λ0(p::P{N,T}) where {N,T} must return a SymEngine.Basic object representing the symbolic expression for the λ0 part of the ODE.\nQuasinormalModes.S0(p::P{N,T}) where {N,T} must return a SymEngine.Basic object representing the symbolic expression for the S0 part of the ODE.\nQuasinormalModes.get_ODEvar(p::P{N,T}) where {N,T} must return a SymEngine.Basic objects representing the SymEngine variable associated with the ODE's variable.\nQuasinormalModes.get_ODEeigen(p::P{N,T}) where {N,T} must return a SymEngine.Basic objects representing the SymEngine variable associated with the ODE's eigenvalue.","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"If a problem type P{N,T} is a sub-type of NumericAIMProblem{N,T}, the user must extend the default implementations abiding by the following rules","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"QuasinormalModes.λ0(p::P{N,T}) where {N,T} must return a lambda function of two parameters, the first representing the ODE's variable and the second representing the ODE's eigenvalue where the body represents the expression for the λ0 part of the ODE.\nQuasinormalModes.S0(p::P{N,T}) where {N,T} must return a lambda function of two parameters, the first representing the ODE's variable and the second representing the ODE's eigenvalue where the body represents the expression for the S0 part of the ODE.","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"All problems P{N,T} that are a sub-type of AIMProblem{N,T} must extend the default implementations abiding by the following rules","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"QuasinormalModes.get_niter(p::P{N,T}) where {N,T} must return an unsigned number of type N representing the number of iterations for the AIM to perform.\nQuasinormalModes.get_x0(p::P{N,T}) where {N,T} must return a number of type T representing the evaluation point of the AIM.","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"In the following sections, concrete examples of problems will be illustrated in order to better acquaint the user with the package and hopefully clear out any remaining misunderstandings.","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"note: Semi-analytic VS numeric approach\nBecause of the semi-analytic nature of the operation performed when a structure is a subtype of AnalyticAIMProblem, QuasinormalModes.jl is naturally slower to compute modes in this case. One may also find that for a large number of iterations the AIM might even fail to find modes. A general good approach would be to use the semi-analytic mode to generate lists of eigenvalues for a number of iterations that runs reasonably fast and then use these results as initial guesses for the numeric mode with a high number of iterations.","category":"page"},{"location":"org/#The-memory-cache","page":"Package organization","title":"The memory cache","text":"","category":"section"},{"location":"org/","page":"Package organization","title":"Package organization","text":"In order to minimize memory allocations, all functions that actually compute eigenvalues require a AIMCache object. Given a certain a problem P{N,T} it initializes memory for 8 arrays of size get_niter(p) + one(N) elements of type T. These arrays are used to store intermediate and final computation results. By using a cache object, we guarantee that memory for the computation data is allocated only once and not at each step of the AIM.","category":"page"},{"location":"org/#Stepping-methods","page":"Package organization","title":"Stepping methods","text":"","category":"section"},{"location":"org/","page":"Package organization","title":"Package organization","text":"In order to compute delta_n, QuasinormalModes.jl evolves lambda_0 and s_0 according to the previously stated equations. The evolution from step 1 to step n must happen sequentially but the step itself, that is, the computation of new values of lambda and s from old ones can be performed in parallel. We've provided singleton types that allow the user to control this behavior by passing instances of those types to the eigenvalue computing functions. The user can currently choose the following stepping methods:","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"Serial: Each instruction in a single AIM step is executed sequentially.\nThreaded: Instruction in a single AIM step is executed in parallel using Julia's built-in Threads.@threads macro.","category":"page"},{"location":"org/#Computing-eigenvalues-and-general-workflow-guidelines","page":"Package organization","title":"Computing eigenvalues and general workflow guidelines","text":"","category":"section"},{"location":"org/","page":"Package organization","title":"Package organization","text":"To compute eigenvalues, 3 functions are provided:","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"computeDelta!: Computes the AIM \"quantization condition\" delta_n.\ncomputeEigenvalues: Computes a single, or a list of eigenvalues.\neigenvaluesInGrid: Find all eigenvalues in a certain numerical grid.","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"Depending on the problem type, these functions return and behave differently. In a QuadraticEigenvalueProblem.","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"computeDelta!: Returns a polynomial whose roots are the eigenvalues of the ODE.\ncomputeEigenvalues: Computes the complete list of eigenvalues given by the roots of the computed polynomial.","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"In a NumericAIMProblem,","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"computeDelta!: Returns a value of the quantization condition at a given point in the complex plane.\ncomputeEigenvalues: Computes a single eigenvalues from an initial trial frequency.\neigenvaluesInGrid: Attempts to find eigenvalues using a grid of real or complex data points as initial trial frequencies passed to NLSolve.","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"For more detail on these functions and their behaviors with each problem type refer to the the API Reference where specific descriptions can be found. ","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"The AIM provides the user with \"two degrees of freedom\" when computing eigenvalues: The number of iterations to perform (which we refer by n) and the point around which the ODE functions will be expanded (which we refer byx_0). Additionally, our implementation asks for an initial guess in NumericAIMProblems to find the roots of delta_n, adding yet another degree of freedom to the method. So far, the literature around the AIM cannot provide a general prescription for choosing optimal values for n or x_0, however, it is know that x_0 can affect the speed at which the method converges to a correct solution and if n is chosen to be too small, no eigenvalues will be found. Furthermore, because computeEigenvalues employ a Newton-like rootfinding method (provided by NLSolve) that is based on an initial guess for the root, choosing this guess \"too far\" from the correct solution might not converge to a root or it might be that the root is unstable and any small perturbation around an initial guess produces wildly different results. That being said, we can still outline a general procedure that works empirically when finding quasinormal modes based on the different problem types.","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"First, when the optimal values of n and x_0 are unknown, start with x_0 in the midpoint of the compactified domain and n around 20 or 30. This number of iterations will not yield the the most accurate results but it will be enough to determine if we are on the right track while also not being too computationally expensive. From here, we can take one of two different paths:","category":"page"},{"location":"org/","page":"Package organization","title":"Package organization","text":"If we have a QuadraticEigenvalueProblem, we will have a list of several eigenvalue candidates that are roots of the delta_n polynomial but are not necessarily eigenvalues of the ODE. To determine the true eigenvalues, we need to call computeEigenvalues repeatedly with an increasing number of AIM iterations. Eigenvalues that persist or change slowly when the number of iterations changes are very likely to be true eigenvalues of the ODE. Other values are likely to be spurious numerical results. This procedure is similar to the one employed when computing eigenvalues using pseudospectral methods: Various spurious results are produced and the true ones are found by repeatedly refining and comparing results. Once true eigenvalues start to emerge, we can start to play around with x_0 to see if more eigenvalues emerge in the list.\nIf we have a NumericAIMProblem, a call to computeEigenvalues can only produce a single eigenvalue based on an initial guess. Assuming that the NLSolve actually converges to a solution this mode is also under the peril of returning spurious results. Here, the wisdom of the QuadraticEigenvalueProblems remains: True results must be refined when the number of iterations increase (indicating numerical convergence). If the returned eigenvalue changes wildly for a fixed initial guess this might indicate that the result is spurious. Once an eigenvalue is found, fine tuning to x_0 can be made. A good value for x_0 will make NLSolve converge to a root faster (with less iterations) than a bad one. Also, note that the optimal x_0 value for a certain eigenvalue might not be optimal for all eigenvalues in the spectrum of the ODE (this has been observed empirically). This means that if we are sure that there is an eigenvalue in the vicinity of an initial guess (because we have obtained it with another method, for instance) and computeEigenvalues cannot find it even when the number of AIM iterations is high, tuning x_0 might make these modes emerge. Furthermore, in NumericAIMProblems the function computeDelta! is a point-wise function that returns the value of delta_n anywhere in the complex plane. Using this function, the user can employ a different root finding method than NLSolve. This flexibility allows one to eliminate the additional degree of freedom imposed by the initial guess. We can, for instance, use RootsAndPoles.jl to find all roots of delta_n or any other root finding method desired.","category":"page"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This package's primary objective is to compute the discrete eigenvalues of second order ordinary differential equations. It was written with the intent to be used for computing quasinormal modes (QNMs) of black holes in General Relativity efficiently and accurately. QNMs are the discrete spectrum of characteristic oscillations produced by black holes when perturbed. These oscillations decay exponentially in time and thus it's said that QNMs contain a real omega_R oscillation frequency and an imaginary omega_I frequency that represents the mode's decay rate. These frequencies are often described by a discrete eigenvalue in a second order ODE. For a comprehensive review see [1].","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"To compute eigenvalues (and thus quasinormal frequencies) this package uses the Asymptotic Iteration Method (AIM) [2], more specifically the \"improved\" version of the AIM as described in [3]. The AIM can be used to find the eigenvectors and eigenvalues of any second order differential equation (the class of problems with which the quasinormal modes belong) and thus this package can be used not only in the context of General Relativity but can also be used to find the discrete eigenvalues of other systems such as the eigenenergies of a quantum system described by the time independent Schrödinger equation.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In the following sections you will find the QuasinormalModes.jl API and instructions on how to use it in a series of (hopefully sufficient) examples.","category":"page"},{"location":"intro/#Installing","page":"Introduction","title":"Installing","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This package can be installed using the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"pkg> add QuasinormalModes","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"and then type backspace to exit back to the REPL.","category":"page"},{"location":"#Table-of-Contents","page":"Table of Contents","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"Pages = [\"intro.md\", \"org.md\", \"schw.md\", \"sho.md\", \"api_ref.md\"]","category":"page"},{"location":"api_ref/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api_ref/","page":"API Reference","title":"API Reference","text":"Here we present the API reference for all functions and types within the module. The end user must only use the exported objects but private objects are also documented for completeness","category":"page"},{"location":"api_ref/#Public-Modules","page":"API Reference","title":"Public Modules","text":"","category":"section"},{"location":"api_ref/","page":"API Reference","title":"API Reference","text":"Modules = [QuasinormalModes]\nPrivate = false\nOrder   = [:module]","category":"page"},{"location":"api_ref/#QuasinormalModes.QuasinormalModes","page":"API Reference","title":"QuasinormalModes.QuasinormalModes","text":"This package contains routines for computing eigenvalues of second order ordinary differential equations and in particular the quasinormal modes (QNMs) of black holes in General Relativity using the \"Asymptotic Iteration Method\" [1] using the implementation based on the \"improved\" version of the AIM, described in [2].\n\nReferences:\n\n1 2\n\n\n\n\n\n","category":"module"},{"location":"api_ref/#Public-types","page":"API Reference","title":"Public types","text":"","category":"section"},{"location":"api_ref/","page":"API Reference","title":"API Reference","text":"Modules = [QuasinormalModes]\nPrivate = false\nOrder   = [:type]","category":"page"},{"location":"api_ref/#QuasinormalModes.AIMCache","page":"API Reference","title":"QuasinormalModes.AIMCache","text":"Cache of coefficient arrays for the AIM. To each AIM problem corresponds a cache. As long as the problem doesn't change, the cache can be reused.\n\nMembers\n\nicda::Array{T,1}: Hold the initial c data, i.e., c^i_0.\nccda::Array{T,1}: Hold the coefficients for the current aim step, c^i_n.\npcda::Array{T,1}: Hold the coefficients for the previous aim step, c^i_{n-1}.\nbcda::Array{T,1}: The work buffer used to actually compute the c coefficients in parallel.\nidda::Array{T,1}: Hold the initial d data, i.e., c^i_0.\ncdda::Array{T,1}: Hold the coefficients for the current aim step, d^i_n.\npdda::Array{T,1}: Hold the coefficients for the previous aim step, d^i_{n-1}.\nbdda::Array{T,1}: The work buffer used to actually compute the d coefficients in parallel.\nsize::N: The size of the arrays in the cache.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#QuasinormalModes.AIMCache-Union{Tuple{NumericAIMProblem{N, T}}, Tuple{T}, Tuple{N}} where {N<:Unsigned, T<:Number}","page":"API Reference","title":"QuasinormalModes.AIMCache","text":"AIMCache(p::NumericAIMProblem{N,T}) where {N <: Unsigned, T <: Number}\n\nCreate an AIMCache object suitable for Numeric Eigenvalue Problems.\n\nInput\n\np::NumericAIMProblem: The problem data.\n\nOutput\n\nAn AIMCache{N,T} object.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.AIMCache-Union{Tuple{QuadraticEigenvalueProblem{N, T}}, Tuple{T}, Tuple{N}} where {N<:Unsigned, T<:Number}","page":"API Reference","title":"QuasinormalModes.AIMCache","text":"AIMCache(p::QuadraticEigenvalueProblem{N,T}) where {N <: Unsigned, T <: Number}\n\nCreate an AIMCache object suitable for Quadratic Eigenvalue Problems.\n\nInput\n\np::QuadraticEigenvalueProblem: The problem data.\n\nOutput\n\nAn AIMCache{N,Polynomial{T}} object.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.AIMProblem","page":"API Reference","title":"QuasinormalModes.AIMProblem","text":"Parent super-type of all problems that can be solved using the AIM.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#QuasinormalModes.AnalyticAIMProblem","page":"API Reference","title":"QuasinormalModes.AnalyticAIMProblem","text":"Parent super-type of all problems that can be solved using the AIM semi-analytically.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#QuasinormalModes.NumericAIMProblem","page":"API Reference","title":"QuasinormalModes.NumericAIMProblem","text":"Parent super-type of all problems that can be solved using the AIM numerically.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#QuasinormalModes.QuadraticEigenvalueProblem","page":"API Reference","title":"QuasinormalModes.QuadraticEigenvalueProblem","text":"Parent super-type of all problems whose eigenvalue is a quadratic polynomial.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#QuasinormalModes.Serial","page":"API Reference","title":"QuasinormalModes.Serial","text":"Perform all AIM steps sequentially\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#QuasinormalModes.Threaded","page":"API Reference","title":"QuasinormalModes.Threaded","text":"Perform all AIM steps in parallel using threads\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#Public-functions","page":"API Reference","title":"Public functions","text":"","category":"section"},{"location":"api_ref/","page":"API Reference","title":"API Reference","text":"Modules = [QuasinormalModes]\nPrivate = false\nOrder   = [:function]","category":"page"},{"location":"api_ref/#QuasinormalModes.S0-Tuple{T} where T","page":"API Reference","title":"QuasinormalModes.S0","text":"All problem types must implement a S0 function. This behavior is enforced by the default implementations.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.computeDelta!-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, NumericAIMProblem{N, T}, AIMCache{N, T}, T}} where {N<:Unsigned, T<:Number}","page":"API Reference","title":"QuasinormalModes.computeDelta!","text":"computeDelta!(m::AIMSteppingMethod, p::NumericAIMProblem{N,T}, c::AIMCache{N,T}, ω::T) where {N <: Unsigned, T <: Number}\n\nCompute and return the AIM \"quantization condition\".\n\nInput\n\nm::AIMSteppingMethod: The stepping method to use.\np::QuadraticEigenvalueProblem: A quadratic frequency problem.\nc::AIMCache: An AIM cache object created from p.\nω::T: Point to evaluate the quantization condition.\n\nOutput\n\nAn object of type T which represents the AIM quantization condition at point ω.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.computeDelta!-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, QuadraticEigenvalueProblem{N, T}, AIMCache{N, Polynomials.Polynomial{T, X} where X}}} where {N<:Unsigned, T<:Number}","page":"API Reference","title":"QuasinormalModes.computeDelta!","text":"computeDelta!(p::QuadraticEigenvalueProblem{N,T}, c::AIMCache{N,Polynomial{T}}) where {N <: Unsigned, T <: Number}\n\nCompute and return the AIM \"quantization condition\".\n\nInput\n\nm::AIMSteppingMethod: The stepping method to use.\np::QuadraticEigenvalueProblem: A quadratic frequency problem.\nc::AIMCache: An AIM cache object created from p.\n\nOutput\n\nAn object of type Polynomial{T} whose roots are the problem's eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.computeEigenvalues-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, NumericAIMProblem{N, T}, AIMCache{N, T}, T}} where {N<:Unsigned, T<:Complex}","page":"API Reference","title":"QuasinormalModes.computeEigenvalues","text":"computeEigenvalues(\n    m::AIMSteppingMethod,\n    p::NumericAIMProblem{N,T},\n    c::AIMCache{N,T},\n    guess::T;\n    nls_xtol::Real = convert(T, 1.0e-10),\n    nls_ftol::Real = convert(T, 1.0e-10),\n    nls_iterations::Int = 1000\n    ) where {N <: Unsigned, T <: Complex}\n\nCompute a single eigenvalue for the problem p with corresponding cache c.\n\nInput\n\nm::AIMSteppingMethod: The stepping method to use.\np::NumericAIMProblem: The previously defined problem data.\nc::AIMCache: The cache constructed from p.\nnls_xtol::Real: Norm difference in x between two successive iterates under which convergence is declared.\nnls_ftol::Real: Infinite norm of residuals under which convergence is declared.\nnls_iterations::Int: Maximum number of iterations performed by NLsolve.\n\nOutput\n\nAn object of type SolverResults returned by nlsolve. See NLsolve.jl for further details.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.computeEigenvalues-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, NumericAIMProblem{N, T}, AIMCache{N, T}, T}} where {N<:Unsigned, T<:Real}","page":"API Reference","title":"QuasinormalModes.computeEigenvalues","text":"computeEigenvalues(\n    m::AIMSteppingMethod,\n    p::NumericAIMProblem{N,T},\n    c::AIMCache{N,T},\n    guess::T;\n    roots_atol::Real = 1.0e-10,\n    roots_rtol::Real = 1.0e-10,\n    roots_xatol::Real = 1.0e-10,\n    roots_xrtol::Real = 1.0e-10,\n    roots_maxevals::Int = 100\n    ) where {N <: Unsigned, T <: Real}\n\nCompute a single eigenvalue for the problem p with corresponding cache c. For details on convergence settings see Roots.jl.\n\nInput\n\nm::AIMSteppingMethod: The stepping method to use.\np::NumericAIMProblem{N,T}: The previously defined problem data.\nc::AIMCache{N,T}: The cache constructed from p.\ngrid::Tuple{T,T}: A tuple consisting of (start point, end point).\nroots_atol::Real: Absolute tolerance.\nroots_rtol::Real: Relative tolerance.\nroots_xatol::Real: Floating point comparison absolute tolerance.\nroots_xrtol::Real: Floating point comparison relative tolerance.\nroots_maxevals::Int: Number of algorithm iterations performed.\n\nOutput\n\nAn object of type T containing the found eigenvalue.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.computeEigenvalues-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, QuadraticEigenvalueProblem{N, T}, AIMCache{N, Polynomials.Polynomial{T, X} where X}}} where {N<:Unsigned, T<:Number}","page":"API Reference","title":"QuasinormalModes.computeEigenvalues","text":"computeEigenvalues(\n    m::AIMSteppingMethod,\n    p::QuadraticEigenvalueProblem{N,T},\n    c::AIMCache{N,Polynomial{T}};\n    plr_polish::Bool = true, \n    plr_epsilon::Real = convert(T, 1.0e-10)\n    ) where {N <: Unsigned, T <: Number}\n\nCompute the eigenvalues for the problem p with corresponding cache c.\n\nInput\n\nm::AIMSteppingMethod: The stepping method to use.\np::QuadraticEigenvalueProblem: The previously defined problem data.\nc::AIMCache: The cache constructed from p.\nplr_polish::Bool: Tell PolynomialRoots to divide the original polynomial by each root found and polish the results using the full polynomial.\nplr_epsilon::Real: The stopping criterion described in Skowron & Gould paper. This is not the precision with which the roots will be calculated.\n\nOutput\n\nAn object of type Array{T,1} containing the computed eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.eigenvaluesInGrid-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, NumericAIMProblem{N, T}, AIMCache{N, T}, Tuple{T, T, Int64, Int64}}} where {N<:Unsigned, T<:Complex}","page":"API Reference","title":"QuasinormalModes.eigenvaluesInGrid","text":"eigenvaluesInGrid(\n    m::AIMSteppingMethod,\n    p::NumericAIMProblem{N,T},\n    c::AIMCache{N,T},\n    grid::Tuple{T,T,Int64,Int64};\n    xtol::Real = 1.0e-10,\n    ftol::Real = 1.0e-10,\n    iterations::Int = 1000\n    ) where {N <: Unsigned, T <: Complex}\n\nAttempts to find eigenvalues using a grid of complex plane data points as initial guesses passed to nlsolve.\n\nInput\n\nm::AIMSteppingMethod: The stepping method to use.\np::NumericAIMProblem{N,T}: The previously defined problem data.\nc::AIMCache{N,T}: The cache constructed from p.\ngrid::Tuple{T,T,Int64,Int64}: A tuple consisting of (start point, end point, num. of real pts., num. of imag. pots.).\nxtol::Real: Norm difference in x between two successive iterates under which convergence is declared.\nftol::Real: Infinite norm of residuals under which convergence is declared.\niterations::Int: Maximum number of iterations performed by NLsolve.\n\nOutput\n\nAn object of type Array{T,1} containing the modes found within the grid.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.eigenvaluesInGrid-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, NumericAIMProblem{N, T}, AIMCache{N, T}, Tuple{T, T}}} where {N<:Unsigned, T<:Real}","page":"API Reference","title":"QuasinormalModes.eigenvaluesInGrid","text":"eigenvaluesInGrid(\n    m::AIMSteppingMethod,\n    p::NumericAIMProblem{N,T},\n    c::AIMCache{N,T},\n    grid::Tuple{T,T};\n    roots_atol::Real = 1.0e-10,\n    roots_rtol::Real = 1.0e-10,\n    roots_xatol::Real = 1.0e-10,\n    roots_xrtol::Real = 1.0e-10,\n    roots_maxevals::Int = 100\n    ) where {N <: Unsigned, T <: Real}\n\nAttempts to find eigenvalues using a range of real data points as a search region to find_zeros. For details on convergence settings see Roots.jl.\n\nInput\n\nm::AIMSteppingMethod: The stepping method to use.\np::NumericAIMProblem{N,T}: The previously defined problem data.\nc::AIMCache{N,T}: The cache constructed from p.\ngrid::Tuple{T,T}: A tuple consisting of (start point, end point).\nroots_atol::Real: Absolute tolerance.\nroots_rtol::Real: Relative tolerance.\nroots_xatol::Real: Floating point comparison absolute tolerance.\nroots_xrtol::Real: Floating point comparison relative tolerance.\nroots_maxevals::Int: Number of algorithm iterations performed.\n\nOutput\n\nAn object of type Array{T,1} containing the eigenvalues found within the grid.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.get_ODEeigen-Tuple{T} where T","page":"API Reference","title":"QuasinormalModes.get_ODEeigen","text":"Analytic problems must implement an acessor to the eigenvalue of the ODE.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.get_ODEvar-Tuple{T} where T","page":"API Reference","title":"QuasinormalModes.get_ODEvar","text":"Analytic problems must implement an acessor to the variable of the ODE.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.get_niter-Tuple{T} where T","page":"API Reference","title":"QuasinormalModes.get_niter","text":"All problem types must implement get_niter to return the number of iterations to perform.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.get_x0-Tuple{T} where T","page":"API Reference","title":"QuasinormalModes.get_x0","text":"All problem types must implement get_x0 to return AIM's point of evaluation.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.λ0-Tuple{T} where T","page":"API Reference","title":"QuasinormalModes.λ0","text":"All problem types must implement a λ0 function. This behavior is enforced by the default implementations.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#Private-types","page":"API Reference","title":"Private types","text":"","category":"section"},{"location":"api_ref/","page":"API Reference","title":"API Reference","text":"Modules = [QuasinormalModes]\nPublic = false\nOrder   = [:type]","category":"page"},{"location":"api_ref/#QuasinormalModes.AIMSteppingMethod","page":"API Reference","title":"QuasinormalModes.AIMSteppingMethod","text":"Super-type of all stepping methods used internally by the AIM.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#QuasinormalModes.AnalyticityTrait","page":"API Reference","title":"QuasinormalModes.AnalyticityTrait","text":"Super-type of traits describing the analyticity of eigenvalue problems.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#QuasinormalModes.AnalyticityTrait-Tuple{Type{var\"#s8\"} where var\"#s8\"<:AnalyticAIMProblem}","page":"API Reference","title":"QuasinormalModes.AnalyticityTrait","text":"The trait of AnalyticAIMProblem(s).\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.AnalyticityTrait-Tuple{Type{var\"#s8\"} where var\"#s8\"<:NumericAIMProblem}","page":"API Reference","title":"QuasinormalModes.AnalyticityTrait","text":"The trait of NumericAIMProblem(s).\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.AnalyticityTrait-Tuple{Type{var\"#s9\"} where var\"#s9\"<:AIMProblem}","page":"API Reference","title":"QuasinormalModes.AnalyticityTrait","text":"The default trait of AIMProblem(s).\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.IsAnalytic","page":"API Reference","title":"QuasinormalModes.IsAnalytic","text":"All problems with eigenvalues that can be described by analytic functions have this trait.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#QuasinormalModes.IsNumeric","page":"API Reference","title":"QuasinormalModes.IsNumeric","text":"All problems with eigenvalues that can't be described by analytic functions have this trait.\n\n\n\n\n\n","category":"type"},{"location":"api_ref/#Private-functions","page":"API Reference","title":"Private functions","text":"","category":"section"},{"location":"api_ref/","page":"API Reference","title":"API Reference","text":"Modules = [QuasinormalModes]\nPublic = false\nOrder   = [:function]","category":"page"},{"location":"api_ref/#QuasinormalModes.AIMStep!-Union{Tuple{U}, Tuple{T}, Tuple{N}, Tuple{Serial, AIMProblem{N, T}, AIMCache{N, U}}} where {N<:Unsigned, T<:Number, U}","page":"API Reference","title":"QuasinormalModes.AIMStep!","text":"AIMStep!(::Serial, p::AIMProblem{N,T}, c::AIMCache{N,U}) where {N <: Unsigned, T <: Number, U <: Any}\n\nPerforms a single step of the AIM algorithm sequentially:\n\nThe initial data arrays are not altered.\nThe previous arrays receive the values of the current arrays.\nThe results of the next step computed using the initial and current arrays. Results are stored in the buffer arrays.\nThe current arrays receive the contents of the buffer arrays.\n\nInput\n\n::Serial: Instance of Serial object.\np::AIMProblem: The problem data to use in the computation.\nc::AIMCache: The cache of arrays that corresponds to the problem p.\n\nOutput\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.AIMStep!-Union{Tuple{U}, Tuple{T}, Tuple{N}, Tuple{Threaded, AIMProblem{N, T}, AIMCache{N, U}}} where {N<:Unsigned, T<:Number, U}","page":"API Reference","title":"QuasinormalModes.AIMStep!","text":"AIMStep!(::Threaded, p::AIMProblem{N,T}, c::AIMCache{N,U}) where {N <: Unsigned, T <: Number, U <: Any}\n\nPerforms a single step of the AIM algorithm in parallel using threads:\n\nThe initial data arrays are not altered.\nThe previous arrays receive the values of the current arrays.\nThe results of the next step computed using the initial and current arrays. Results are stored in the buffer arrays.\nThe current arrays receive the contents of the buffer arrays.\n\nInput\n\n::Threaded: Instance of the Threaded object.\np::AIMProblem: The problem data to use in the computation.\nc::AIMCache: The cache of arrays that corresponds to the problem p.\n\nOutput\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.computePolynomialFactors-Union{Tuple{T}, Tuple{N}, Tuple{QuadraticEigenvalueProblem{N, T}, N, Function}} where {N<:Unsigned, T<:Number}","page":"API Reference","title":"QuasinormalModes.computePolynomialFactors","text":"computePolynomialFactors(p::QuadraticEigenvalueProblem{N,T}, n::N, f::Function) where {N <: Unsigned, T <: Number}\n\nCreate a second order Polynomial object in the variable ω by computing derivatives of λ0 or S0.\n\nInput\n\np::QuadraticEigenvalueProblem: The problem data with the expressions to compute the derivative.\nn::Unsigned: The order of the derivative.\nf::Function: the function to extract the polynomial from. Either λ0 or S0.\n\nOutput\n\nAn object of type Polynomial{T} containing the polynomial resulting from the derivation of the expression.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.createPoly-Union{Tuple{T}, Tuple{N}, Tuple{QuadraticEigenvalueProblem{N, T}, N, Function}} where {N<:Unsigned, T<:Number}","page":"API Reference","title":"QuasinormalModes.createPoly","text":"createPoly(p::QuadraticEigenvalueProblem{N,T}, n::N, f::Function)\n\nCompute the n-th coefficient of the Taylor expansion around x0 for the functions λ0 or S0\n\nInput\n\np::QuadraticEigenvalueProblem: The problem data with the expressions to compute the derivative.\nn::Unsigned: The order of the derivative.\nf::Function: the function to extract the polynomial from. Either λ0 or S0.\n\nOutput\n\nAn object of type Polynomial{T} containing the polynomial Taylor coefficient.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.dnx-Union{Tuple{T}, Tuple{N}, Tuple{AnalyticAIMProblem{N, T}, N, Function, Function}} where {N<:Unsigned, T<:Number}","page":"API Reference","title":"QuasinormalModes.dnx","text":"dnx(p::AnalyticAIMProblem{N,T}, n::N, f::Function, v::Function) where {N <: Unsigned, T <: Number}\n\nComputes the n-th derivative of the AIM expressions with respect to ODE's variable. This function is only a thin wrapper around SymEngine's own diff function. It works as a barrier function that produces a type stable Basic result.\n\nInput\n\np::AnalyticAIMProblem: The problem data with the expressions to compute the derivative.\nn::Unsigned: The order of the derivative.\nf::Function: The actual expression to compute the derivative. Either λ0 or S0.\nv::Function: The variable with respec to which the derivative will be computed. Either getODEvar or getODEeigen.\n\nOutput\n\nA SymEngine.Basic object with the derived expression.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.dnx-Union{Tuple{T}, Tuple{T, SymEngine.Basic, SymEngine.Basic}} where T<:Unsigned","page":"API Reference","title":"QuasinormalModes.dnx","text":"dnx(n::T, f::Basic, v::Basic) where {T <: Unsigned}\n\nComputes the n-th derivative of the the function f with respect to the variable v. This function re implements SymEngine's own diff function using an early quitting strategy.\n\nInput\n\nn::T: The order of the derivative.\nf::Basic: The expression to compute the derivative.\nv::Basic: The variable with respect to which the derivative will be computed.\n\nOutput\n\nA SymEngine.Basic object with the derived expression.\n\n\n\n\n\n","category":"method"},{"location":"api_ref/#QuasinormalModes.recomputeInitials!-Union{Tuple{T}, Tuple{N}, Tuple{NumericAIMProblem{N, T}, AIMCache{N, T}, T}} where {N<:Unsigned, T<:Number}","page":"API Reference","title":"QuasinormalModes.recomputeInitials!","text":"recomputeInitials(p::NumericAIMProblem{N,T}, c::AIMCache{N,T}, ω::T) where {N <: Unsigned, T <: Number}\n\nReevaluate (in-place) the initial data arrays. The initial data array elements are the Taylor expansion coefficients of λ0 and S0 in the ODE variable x around x0 of order get_niter(p) at a point ω.\n\nInput\n\np::NumericAIMProblem: The problem data.\nc::AIMCache: The problem data associated cache.\nω::T: The value of the eigenvalue to evaluate the arrays in.\n\nOutput\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"schw/#Complete-Example:-Schwarzschild-Quasinormal-Modes","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"","category":"section"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"To illustrate how to use QuasinormalModes.jl we will show from start to finish how to compute the quasinormal modes of a Schwarzschild black hole perturbed by an external field. This section will follow closely Emanuele Berti's lectures on black hole perturbation theory, which can be found here and in Ref. [3]","category":"page"},{"location":"schw/#Mathematical-preliminaries","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Mathematical preliminaries","text":"","category":"section"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Let's say that our Schwarzschild black hole is being perturbed by an external field psi_ls where s is the spin of the field (s = 0 1 2 for scalar, electromagnetic and gravitational perturbations, respectively) and l is the angular index of the perturbation. Using mass units such that 2M=1 the \"master\" radial equation governing the perturbation is ","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"r(r-1)psi_ls^primeprime(r) + psi_ls^prime(r) - left l(l+1) - fracs^2-1r - fracomega^2 r^3r-1 rightpsi_ls(r) = 0","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"where primes denote derivatives with respect to the radial coordinate r and omega are the quasinormal frequencies. Since we are solving for quasinormal modes, we need to enforce the proper boundary conditions in the master equation: classically no wave can escape from the BH's event horizon and at spatial infinity waves can only \"leave\" the space-time. It's thus said that our field is purely ingoing in the event horizon (when rrightarrow 1) and purely outgoing at spatial infinity (when rrightarrowinfty). Mathematically, this means that the solution to the master equation must be of the form","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"psi_ls(r) = (r-1)^-i omega r^2 i omega e^i omega (r-1)f_ls(r)","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"By substituting this solution ansatz in the master equation, we obtain a new 2nd order ODE, now for the function f_ls(r). This new ODE is enforcing the correct quasinormal mode boundary conditions. This process usually referred to as incorporating the boundary conditions into the differential equation. The resulting equation reads","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"r left((r-1) r f^primeprime(r)+left(1+2 i left(r^2-2right) omega right) f^prime(r)right)+f(r) left(-r left(l^2+l-4 omega ^2right)+s^2+(2 omega +i)^2right) = 0","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"The last step, although not strictly required, facilitates the numerical handling of the equation. Because the radial coordinates extends from the event horizon to infinity, that is, rin 1infty and computers can't handle infinities, we re-scale the ODE's domain to a finite one. This can be easily done with the change of variables","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"x = 1 - frac1r","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"which implies that when r=1 we have x=0 and when rrightarrowinfty we have x = 1. Thus the solution domain has been successfully compactifyied in the interval xin01. By making this change of variables we get to the final form of the master equation which we will actually feed to QuasinormalModes.jl","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"-x (x-1)^2 f^primeprime(x) + (x (4 i (x-2) omega -3 x+4)+2 i omega -1) f^prime(x)+f(x) left(l^2+l+left(s^2-1right) (x-1)+4 (x-2) omega ^2+4 i (x-1) omega right) = 0","category":"page"},{"location":"schw/#Implementing-the-master-equation-as-an-analytic-problem","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Implementing the master equation as an analytic problem","text":"","category":"section"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"The first step is to load the required packages to run this example: QuasinormalModes and SymEngine:","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"using QuasinormalModes\nusing SymEngine","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Next, we create a parametric type that sub-types AnalyticAIMProblem. As the eigenvalue in the master equation is a quadratic polynomial, we will sub-type QuadraticEigenvalueProblem with the following structure:","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"struct SchwarzschildData{N,T} <: QuadraticEigenvalueProblem{N,T}\n    nIter::N\n    x0::T\n\n    vars::Tuple{Basic, Basic}\n    exprs::Tuple{Basic, Basic}\nend","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"As the reader might notice the structure is quite simple. The variables nIter and x0 store the AIM's number of iterations and expansion point, respectively while vars will be responsible for storing the SymEngine variables representing the ODE's variable and eigenvalue, respectively, as a tuple. Finally exprs will store the SymEngine expressions for the λ0 and S0 parts of the ODE.","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Next we create a parametric constructor for SchwarzschildData that will initializes the fields:","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"function SchwarzschildData(nIter::N, x0::T, l::N, s::N) where {N,T}\n    vars = @vars x ω\n\n    λ0 = (-1 + (2*im)*ω + x*(4 - 3*x + (4*im)*(-2 + x)*ω))/((-1 + x)^2*x)\n    S0 = (l + l^2 + (-1 + s^2)*(-1 + x) + (4*im)*(-1 + x)*ω + 4*(-2 + x)*ω^2)/((-1 + x)^2*x)\n\n    return SchwarzschildData{N,T}(nIter, x0, vars, (λ0, S0))\nend","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"This constructor can be used by passing the values directly instead of explicitly declaring type parameters. The final step is to extend the default accessors functions to operate on SchwarzschildData:","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"QuasinormalModes.λ0(d::SchwarzschildData{N,T}) where {N,T} = d.exprs[1]\nQuasinormalModes.S0(d::SchwarzschildData{N,T}) where {N,T}  = d.exprs[2]\n\nQuasinormalModes.get_niter(d::SchwarzschildData{N,T}) where {N,T} = d.nIter\nQuasinormalModes.get_x0(d::SchwarzschildData{N,T}) where {N,T} = d.x0\n\nQuasinormalModes.get_ODEvar(d::SchwarzschildData{N,T}) where {N,T} = d.vars[1]\nQuasinormalModes.get_ODEeigen(d::SchwarzschildData{N,T}) where {N,T} = d.vars[2]","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"These functions are fairly straightforward accessors and require no additional comment.","category":"page"},{"location":"schw/#Implementing-the-master-equation-as-a-numeric-problem","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Implementing the master equation as a numeric problem","text":"","category":"section"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Again we start by defining a structure but this time around we sub-type NumericAIMProblem","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"struct NSchwarzschildData{N,T} <: NumericAIMProblem{N,T}\n    nIter::N\n    x0::T\n    l::N\n    s::N\nend","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Here nIter and x0 have the same meaning as before, but now instead of storing symbolic variables and expressions we store two additional unsigned integers, l and s. These are the angular and spin parameters of the master equation. Here we must store them in the struct as they can't be \"embedded\" into the expressions for λ0 and S0 as in the analytic case.","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"We proceed once again by creating a more convenient constructor. This time no intermediate computation is required upon construction:","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"function NSchwarzschildData(nIter::N, x0::T, l::N, s::N) where {N,T}\n    return NSchwarzschildData{N,T}(nIter, x0, l, s)\nend","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Finally we extend the default implementations","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"QuasinormalModes.λ0(::NSchwarzschildData{N,T}) where {N,T} = (x,ω) -> (-1 + (2*im)*ω + x*(4 - 3*x + (4*im)*(-2 + x)*ω))/((-1 + x)^2*x)\nQuasinormalModes.S0(d::NSchwarzschildData{N,T}) where {N,T} = (x,ω) -> (d.l + d.l^2 + (-1 + d.s^2)*(-1 + x) + (4*im)*(-1 + x)*ω + 4*(-2 + x)*ω^2)/((-1 + x)^2*x)\n\nQuasinormalModes.get_niter(d::NSchwarzschildData{N,T}) where {N,T} = d.nIter\nQuasinormalModes.get_x0(d::NSchwarzschildData{N,T}) where {N,T} = d.x0","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"This time λ0 and S0 return two parameters lambda functions that will be called multiple times during the evaluation of the AIM. As we've previously mentioned, the first parameters is assumed to be the ODE's variables while the second the ODE's eigenvalue. The body of each lambda is the expression for their respective parts on the ODE.","category":"page"},{"location":"schw/#Constructing-problems-and-initializing-the-cache","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Constructing problems and initializing the cache","text":"","category":"section"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"We create our problems and cache objects by calling the constructors:","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"p_ana = SchwarzschildData(0x00030, Complex(BigFloat(\"0.43\"), BigFloat(\"0.0\")), 0x00000, 0x00000);\np_num = NSchwarzschildData(0x00030, Complex(0.43, 0.0), 0x00000, 0x00000);\n\nc_ana = AIMCache(p_ana)\nc_num = AIMCache(p_num)","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Here we are setting up problems to be solved using 48 iterations with x0 = 0.43 + 0.0*im and l = s = 0.","category":"page"},{"location":"schw/#Computing-the-eigenvalues","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Computing the eigenvalues","text":"","category":"section"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Finally, to compute the quasinormal frequencies we will call computeEigenvalues(Serial(), p_ana, c_ana) (or computeEigenvalues(Threaded(), p_ana, c_ana) if you wish, but don't forget to start julia with the --threads option). This returns an array with all the roots of the quantization condition. We will sort the array by descending order in the imaginary part and after that we will filter the array to remove entries whose real part is too small or with a positive imaginary part and print the result to stdout:","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"m_ana = computeEigenvalues(Serial(), p_ana, c_ana)\n\nfunction printQNMs(qnms, cutoff, instab)\n    println(\"-\"^165)\n    println(\"|\", \" \"^36, \"Re(omega)\", \" \"^36, \" \", \" \"^36, \"Im(omega)\", \" \"^36, \"|\")\n    println(\"-\"^165)\n\n    for qnm in qnms\n        if real(qnm) > cutoff && ( instab ? true : imag(qnm) < big\"0.0\" )\n        println(real(qnm), \"    \", imag(qnm))\n        end\n    end\n    \n    println(\"-\"^165)\n\n    return nothing\nend\n\nsort!(m_ana, by = x -> imag(x))\nprintQNMs(m_ana, 1.0e-10, false)","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"Remember that (as was discussed in here) not all values are actually eigenvalues of the ODE (that is, quasinormal modes). Next we will call","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"ev = computeEigenvalues(Serial(), p_num, c_num, Complex(0.22, -0.20), nls_xtol = 1.0e-10, nls_ftol = 1.0e-10)","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"The variable ev now contains a SolverResults object from the NLsolve.jl package. The first solution element represents the real part of the computed mode while the second represents the imaginary part. The object also contains information about the convergence of the method. Note that with a numerical problem we can only find one mode at a time using a certain initial guess. This can be somewhat remedied by using eigenvaluesInGrid, which uses multiple initial conditions as a guess and collects the converged results.","category":"page"},{"location":"schw/","page":"Complete Example: Schwarzschild Quasinormal Modes","title":"Complete Example: Schwarzschild Quasinormal Modes","text":"The complete source code of this example can be found in schwarzschild.jl","category":"page"}]
}
