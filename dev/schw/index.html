<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Complete Example: Schwarzschild Quasinormal Modes · QuasinormalModes.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="QuasinormalModes.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuasinormalModes.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Table of Contents</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../org/">Package organization</a></li><li class="is-active"><a class="tocitem" href>Complete Example: Schwarzschild Quasinormal Modes</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Mathematical-preliminaries"><span>Mathematical preliminaries</span></a></li><li class="toplevel"><a class="tocitem" href="#Implementing-the-master-equation-as-an-analytic-problem"><span>Implementing the master equation as an analytic problem</span></a></li><li class="toplevel"><a class="tocitem" href="#Implementing-the-master-equation-as-a-numeric-problem"><span>Implementing the master equation as a numeric problem</span></a></li><li class="toplevel"><a class="tocitem" href="#Constructing-problems-and-initializing-the-cache"><span>Constructing problems and initializing the cache</span></a></li><li class="toplevel"><a class="tocitem" href="#Computing-the-eigenvalues"><span>Computing the eigenvalues</span></a></li></ul></li><li><a class="tocitem" href="../sho/">Complete Example: The Harmonic Oscillator</a></li><li><a class="tocitem" href="../api_ref/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Complete Example: Schwarzschild Quasinormal Modes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Complete Example: Schwarzschild Quasinormal Modes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/master/docs/src/schw.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Complete-Example:-Schwarzschild-Quasinormal-Modes"><a class="docs-heading-anchor" href="#Complete-Example:-Schwarzschild-Quasinormal-Modes">Complete Example: Schwarzschild Quasinormal Modes</a><a id="Complete-Example:-Schwarzschild-Quasinormal-Modes-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-Example:-Schwarzschild-Quasinormal-Modes" title="Permalink"></a></h1><p>To illustrate how to use <code>QuasinormalModes.jl</code> we will show from start to finish how to compute the quasinormal modes of a Schwarzschild black hole perturbed by an external field. This section will follow closely Emanuele Berti&#39;s lectures on black hole perturbation theory, which can be found <a href="https://www.dropbox.com/sh/9th1um175m8gco9/AACCIkvNa3h-zdHBMZkQ31Baa?dl=0">here</a> and in Ref. <a href="https://arxiv.org/abs/1111.5024">[3]</a></p><h1 id="Mathematical-preliminaries"><a class="docs-heading-anchor" href="#Mathematical-preliminaries">Mathematical preliminaries</a><a id="Mathematical-preliminaries-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-preliminaries" title="Permalink"></a></h1><p>Let&#39;s say that our Schwarzschild black hole is being perturbed by an external field <span>$\psi_{ls}$</span> where <span>$s$</span> is the spin of the field (<span>$s = 0, 1, 2$</span> for scalar, electromagnetic and gravitational perturbations, respectively) and <span>$l$</span> is the angular index of the perturbation. Using mass units such that <span>$2M=1$</span> the &quot;master&quot; radial equation governing the perturbation is </p><p class="math-container">\[r(r-1)\psi_{ls}^{\prime\prime}(r) + \psi_{ls}^{\prime}(r) - \left[ l(l+1) - \frac{s^2-1}{r} - \frac{\omega^2 r^3}{r-1} \right]\psi_{ls}(r) = 0\]</p><p>where primes denote derivatives with respect to the radial coordinate <span>$r$</span> and <span>$\omega$</span> are the quasinormal frequencies. Since we are solving for quasinormal modes, we need to enforce the proper boundary conditions in the master equation: classically no wave can escape from the BH&#39;s event horizon and at spatial infinity waves can only &quot;leave&quot; the space-time. It&#39;s thus said that our field is purely <em>ingoing</em> in the event horizon (when <span>$r\rightarrow 1$</span>) and purely <em>outgoing</em> at spatial infinity (when <span>$r\rightarrow\infty$</span>). Mathematically, this means that the solution to the master equation must be of the form</p><p class="math-container">\[\psi_{ls}(r) = (r-1)^{-i \omega} r^{2 i \omega} e^{i \omega (r-1)}f_{ls}(r).\]</p><p>By substituting this solution <em>ansatz</em> in the master equation, we obtain a new 2nd order ODE, now for the function <span>$f_{ls}(r)$</span>. This new ODE is enforcing the correct quasinormal mode boundary conditions. This process usually referred to as incorporating the boundary conditions into the differential equation. The resulting equation reads</p><p class="math-container">\[r \left((r-1) r f^{\prime\prime}(r)+\left(1+2 i \left(r^2-2\right) \omega \right) f^\prime(r)\right)+f(r) \left(-r \left(l^2+l-4 \omega ^2\right)+s^2+(2 \omega +i)^2\right) = 0.\]</p><p>The last step, although not strictly required, facilitates the numerical handling of the equation. Because the radial coordinates extends from the event horizon to infinity, that is, <span>$r\in [1,\infty]$</span> and computers can&#39;t handle infinities, we re-scale the ODE&#39;s domain to a finite one. This can be easily done with the change of variables</p><p class="math-container">\[x = 1 - \frac{1}{r}\]</p><p>which implies that when <span>$r=1$</span> we have <span>$x=0$</span> and when <span>$r\rightarrow\infty$</span> we have <span>$x = 1$</span>. Thus the solution domain has been successfully compactifyied in the interval <span>$x\in[0,1]$</span>. By making this change of variables we get to the final form of the master equation which we will actually feed to <code>QuasinormalModes.jl</code></p><p class="math-container">\[-x (x-1)^2 f^{\prime\prime}(x) + (x (4 i (x-2) \omega -3 x+4)+2 i \omega -1) f^\prime(x)+f(x) \left(l^2+l+\left(s^2-1\right) (x-1)+4 (x-2) \omega ^2+4 i (x-1) \omega \right) = 0.\]</p><h1 id="Implementing-the-master-equation-as-an-analytic-problem"><a class="docs-heading-anchor" href="#Implementing-the-master-equation-as-an-analytic-problem">Implementing the master equation as an analytic problem</a><a id="Implementing-the-master-equation-as-an-analytic-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-the-master-equation-as-an-analytic-problem" title="Permalink"></a></h1><p>The first step is to load the required packages to run this example: <code>QuasinormalModes</code> and <code>SymEngine</code>:</p><pre><code class="language-julia hljs">using QuasinormalModes
using SymEngine</code></pre><p>Next, we create a parametric type that sub-types <code>AnalyticAIMProblem</code>. As the eigenvalue in the master equation is a quadratic polynomial, we will sub-type <code>QuadraticEigenvalueProblem</code> with the following structure:</p><pre><code class="language-julia hljs">struct SchwarzschildData{N,T} &lt;: QuadraticEigenvalueProblem{N,T}
    nIter::N
    x0::T

    vars::Tuple{Basic, Basic}
    exprs::Tuple{Basic, Basic}
end</code></pre><p>As the reader might notice the structure is quite simple. The variables <code>nIter</code> and <code>x0</code> store the AIM&#39;s number of iterations and expansion point, respectively while <code>vars</code> will be responsible for storing the <code>SymEngine</code> variables representing the ODE&#39;s variable and eigenvalue, respectively, as a tuple. Finally <code>exprs</code> will store the <code>SymEngine</code> expressions for the <code>λ0</code> and <code>S0</code> parts of the ODE.</p><p>Next we create a parametric constructor for <code>SchwarzschildData</code> that will initializes the fields:</p><pre><code class="language-julia hljs">function SchwarzschildData(nIter::N, x0::T, l::N, s::N) where {N,T}
    vars = @vars x ω

    λ0 = (-1 + (2*im)*ω + x*(4 - 3*x + (4*im)*(-2 + x)*ω))/((-1 + x)^2*x)
    S0 = (l + l^2 + (-1 + s^2)*(-1 + x) + (4*im)*(-1 + x)*ω + 4*(-2 + x)*ω^2)/((-1 + x)^2*x)

    return SchwarzschildData{N,T}(nIter, x0, vars, (λ0, S0))
end</code></pre><p>This constructor can be used by passing the values directly instead of explicitly declaring type parameters. The final step is to extend the default accessors functions to operate on <code>SchwarzschildData</code>:</p><pre><code class="language-julia hljs">QuasinormalModes.λ0(d::SchwarzschildData{N,T}) where {N,T} = d.exprs[1]
QuasinormalModes.S0(d::SchwarzschildData{N,T}) where {N,T}  = d.exprs[2]

QuasinormalModes.get_niter(d::SchwarzschildData{N,T}) where {N,T} = d.nIter
QuasinormalModes.get_x0(d::SchwarzschildData{N,T}) where {N,T} = d.x0

QuasinormalModes.get_ODEvar(d::SchwarzschildData{N,T}) where {N,T} = d.vars[1]
QuasinormalModes.get_ODEeigen(d::SchwarzschildData{N,T}) where {N,T} = d.vars[2]</code></pre><p>These functions are fairly straightforward accessors and require no additional comment.</p><h1 id="Implementing-the-master-equation-as-a-numeric-problem"><a class="docs-heading-anchor" href="#Implementing-the-master-equation-as-a-numeric-problem">Implementing the master equation as a numeric problem</a><a id="Implementing-the-master-equation-as-a-numeric-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-the-master-equation-as-a-numeric-problem" title="Permalink"></a></h1><p>Again we start by defining a structure but this time around we sub-type <code>NumericAIMProblem</code></p><pre><code class="language-julia hljs">struct NSchwarzschildData{N,T} &lt;: NumericAIMProblem{N,T}
    nIter::N
    x0::T
    l::N
    s::N
end</code></pre><p>Here <code>nIter</code> and <code>x0</code> have the same meaning as before, but now instead of storing symbolic variables and expressions we store two additional unsigned integers, <code>l</code> and <code>s</code>. These are the angular and spin parameters of the master equation. Here we must store them in the struct as they can&#39;t be &quot;embedded&quot; into the expressions for <code>λ0</code> and <code>S0</code> as in the analytic case.</p><p>We proceed once again by creating a more convenient constructor. This time no intermediate computation is required upon construction:</p><pre><code class="language-julia hljs">function NSchwarzschildData(nIter::N, x0::T, l::N, s::N) where {N,T}
    return NSchwarzschildData{N,T}(nIter, x0, l, s)
end</code></pre><p>Finally we extend the default implementations</p><pre><code class="language-julia hljs">QuasinormalModes.λ0(::NSchwarzschildData{N,T}) where {N,T} = (x,ω) -&gt; (-1 + (2*im)*ω + x*(4 - 3*x + (4*im)*(-2 + x)*ω))/((-1 + x)^2*x)
QuasinormalModes.S0(d::NSchwarzschildData{N,T}) where {N,T} = (x,ω) -&gt; (d.l + d.l^2 + (-1 + d.s^2)*(-1 + x) + (4*im)*(-1 + x)*ω + 4*(-2 + x)*ω^2)/((-1 + x)^2*x)

QuasinormalModes.get_niter(d::NSchwarzschildData{N,T}) where {N,T} = d.nIter
QuasinormalModes.get_x0(d::NSchwarzschildData{N,T}) where {N,T} = d.x0</code></pre><p>This time <code>λ0</code> and <code>S0</code> return two parameters lambda functions that will be called multiple times during the evaluation of the AIM. As we&#39;ve previously mentioned, the first parameters is assumed to be the ODE&#39;s variables while the second the ODE&#39;s eigenvalue. The body of each lambda is the expression for their respective parts on the ODE.</p><h1 id="Constructing-problems-and-initializing-the-cache"><a class="docs-heading-anchor" href="#Constructing-problems-and-initializing-the-cache">Constructing problems and initializing the cache</a><a id="Constructing-problems-and-initializing-the-cache-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-problems-and-initializing-the-cache" title="Permalink"></a></h1><p>We create our problems and cache objects by calling the constructors:</p><pre><code class="language-julia hljs">p_ana = SchwarzschildData(0x00030, Complex(BigFloat(&quot;0.43&quot;), BigFloat(&quot;0.0&quot;)), 0x00000, 0x00000);
p_num = NSchwarzschildData(0x00030, Complex(0.43, 0.0), 0x00000, 0x00000);

c_ana = AIMCache(p_ana)
c_num = AIMCache(p_num)</code></pre><p>Here we are setting up problems to be solved using 48 iterations with <code>x0 = 0.43 + 0.0*im</code> and <code>l = s = 0</code>.</p><h1 id="Computing-the-eigenvalues"><a class="docs-heading-anchor" href="#Computing-the-eigenvalues">Computing the eigenvalues</a><a id="Computing-the-eigenvalues-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-the-eigenvalues" title="Permalink"></a></h1><p>Finally, to compute the quasinormal frequencies we will call <code>computeEigenvalues(Serial(), p_ana, c_ana)</code> (or <code>computeEigenvalues(Threaded(), p_ana, c_ana)</code> if you wish, but don&#39;t forget to start julia with the <code>--threads</code> option). This returns an array with all the roots of the quantization condition. We will sort the array by descending order in the imaginary part and after that we will filter the array to remove entries whose real part is too small or with a positive imaginary part and print the result to <code>stdout</code>:</p><pre><code class="language-julia hljs">m_ana = computeEigenvalues(Serial(), p_ana, c_ana)

function printQNMs(qnms, cutoff, instab)
    println(&quot;-&quot;^165)
    println(&quot;|&quot;, &quot; &quot;^36, &quot;Re(omega)&quot;, &quot; &quot;^36, &quot; &quot;, &quot; &quot;^36, &quot;Im(omega)&quot;, &quot; &quot;^36, &quot;|&quot;)
    println(&quot;-&quot;^165)

    for qnm in qnms
        if real(qnm) &gt; cutoff &amp;&amp; ( instab ? true : imag(qnm) &lt; big&quot;0.0&quot; )
        println(real(qnm), &quot;    &quot;, imag(qnm))
        end
    end
    
    println(&quot;-&quot;^165)

    return nothing
end

sort!(m_ana, by = x -&gt; imag(x))
printQNMs(m_ana, 1.0e-10, false)</code></pre><p>Remember that (as was discussed in <a href="../org/#Computing-eigenvalues-and-general-workflow-guidelines">here</a>) not all values are actually eigenvalues of the ODE (that is, quasinormal modes). Next we will call</p><pre><code class="language-julia hljs">ev = computeEigenvalues(Serial(), p_num, c_num, Complex(0.22, -0.20), nls_xtol = 1.0e-10, nls_ftol = 1.0e-10)</code></pre><p>The variable <code>ev</code> now contains a <code>SolverResults</code> object from the <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLsolve.jl</a> package. The first solution element represents the real part of the computed mode while the second represents the imaginary part. The object also contains information about the convergence of the method. Note that with a numerical problem we can only find one mode at a time using a certain initial guess. This can be somewhat remedied by using <code>eigenvaluesInGrid</code>, which uses multiple initial conditions as a guess and collects the converged results.</p><p>The complete source code of this example can be found in <a href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/master/examples/schwarzschild.jl">schwarzschild.jl</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../org/">« Package organization</a><a class="docs-footer-nextpage" href="../sho/">Complete Example: The Harmonic Oscillator »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Friday 11 March 2022 01:23">Friday 11 March 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
