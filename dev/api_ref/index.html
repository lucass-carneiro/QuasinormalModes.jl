<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · QuasinormalModes.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="QuasinormalModes.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuasinormalModes.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Table of Contents</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../org/">Package organization</a></li><li><a class="tocitem" href="../schw/">Complete Example: Schwarzschild Quasinormal Modes</a></li><li><a class="tocitem" href="../sho/">Complete Example: The Harmonic Oscillator</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Public-Modules"><span>Public Modules</span></a></li><li><a class="tocitem" href="#Public-types"><span>Public types</span></a></li><li><a class="tocitem" href="#Public-functions"><span>Public functions</span></a></li><li><a class="tocitem" href="#Private-types"><span>Private types</span></a></li><li><a class="tocitem" href="#Private-functions"><span>Private functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/master/docs/src/api_ref.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>Here we present the API reference for all functions and types within the module. The end user must only use the exported objects but private objects are also documented for completeness</p><h2 id="Public-Modules"><a class="docs-heading-anchor" href="#Public-Modules">Public Modules</a><a id="Public-Modules-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Modules" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.QuasinormalModes" href="#QuasinormalModes.QuasinormalModes"><code>QuasinormalModes.QuasinormalModes</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This package contains routines for computing eigenvalues of second order ordinary differential equations and in particular the quasinormal modes (QNMs) of black holes in General Relativity using the &quot;Asymptotic Iteration Method&quot; [1] using the implementation based on the &quot;improved&quot; version of the AIM, described in [2].</p><p>References:</p><p><a href="https://arxiv.org/abs/math-ph/0309066v1">1</a> <a href="https://arxiv.org/abs/1111.5024">2</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/QuasinormalModes.jl#L3-L14">source</a></section></article><h2 id="Public-types"><a class="docs-heading-anchor" href="#Public-types">Public types</a><a id="Public-types-1"></a><a class="docs-heading-anchor-permalink" href="#Public-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.AIMCache" href="#QuasinormalModes.AIMCache"><code>QuasinormalModes.AIMCache</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Cache of coefficient arrays for the AIM. To each AIM problem corresponds a cache. As long as the problem doesn&#39;t change, the cache can be reused.</p><p><strong>Members</strong></p><ul><li><code>icda::Array{T,1}</code>: Hold the initial c data, i.e., c^i_0.</li><li><code>ccda::Array{T,1}</code>: Hold the coefficients for the current aim step, c^i_n.</li><li><code>pcda::Array{T,1}</code>: Hold the coefficients for the previous aim step, c^i_{n-1}.</li><li><code>bcda::Array{T,1}</code>: The work buffer used to actually compute the c coefficients in parallel.</li><li><code>idda::Array{T,1}</code>: Hold the initial d data, i.e., c^i_0.</li><li><code>cdda::Array{T,1}</code>: Hold the coefficients for the current aim step, d^i_n.</li><li><code>pdda::Array{T,1}</code>: Hold the coefficients for the previous aim step, d^i_{n-1}.</li><li><code>bdda::Array{T,1}</code>: The work buffer used to actually compute the d coefficients in parallel.</li><li><code>size::N</code>: The size of the arrays in the cache.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/core/aim_cache.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.AIMCache-Union{Tuple{NumericAIMProblem{N, T}}, Tuple{T}, Tuple{N}} where {N&lt;:Unsigned, T&lt;:Number}" href="#QuasinormalModes.AIMCache-Union{Tuple{NumericAIMProblem{N, T}}, Tuple{T}, Tuple{N}} where {N&lt;:Unsigned, T&lt;:Number}"><code>QuasinormalModes.AIMCache</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AIMCache(p::NumericAIMProblem{N,T}) where {N &lt;: Unsigned, T &lt;: Number}</code></pre><p>Create an AIMCache object suitable for Numeric Eigenvalue Problems.</p><p><strong>Input</strong></p><ul><li><code>p::NumericAIMProblem</code>: The problem data.</li></ul><p><strong>Output</strong></p><p>An <code>AIMCache{N,T}</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/core/aim_cache.jl#L60-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.AIMCache-Union{Tuple{QuadraticEigenvalueProblem{N, T}}, Tuple{T}, Tuple{N}} where {N&lt;:Unsigned, T&lt;:Number}" href="#QuasinormalModes.AIMCache-Union{Tuple{QuadraticEigenvalueProblem{N, T}}, Tuple{T}, Tuple{N}} where {N&lt;:Unsigned, T&lt;:Number}"><code>QuasinormalModes.AIMCache</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AIMCache(p::QuadraticEigenvalueProblem{N,T}) where {N &lt;: Unsigned, T &lt;: Number}</code></pre><p>Create an AIMCache object suitable for Quadratic Eigenvalue Problems.</p><p><strong>Input</strong></p><ul><li><code>p::QuadraticEigenvalueProblem</code>: The problem data.</li></ul><p><strong>Output</strong></p><p>An <code>AIMCache{N,Polynomial{T}}</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/core/aim_cache.jl#L30-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.AIMProblem" href="#QuasinormalModes.AIMProblem"><code>QuasinormalModes.AIMProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parent super-type of all problems that can be solved using the AIM.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/QuasinormalModes.jl#L58-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.AnalyticAIMProblem" href="#QuasinormalModes.AnalyticAIMProblem"><code>QuasinormalModes.AnalyticAIMProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parent super-type of all problems that can be solved using the AIM semi-analytically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/QuasinormalModes.jl#L63-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.NumericAIMProblem" href="#QuasinormalModes.NumericAIMProblem"><code>QuasinormalModes.NumericAIMProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parent super-type of all problems that can be solved using the AIM numerically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/QuasinormalModes.jl#L68-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.QuadraticEigenvalueProblem" href="#QuasinormalModes.QuadraticEigenvalueProblem"><code>QuasinormalModes.QuadraticEigenvalueProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parent super-type of all problems whose eigenvalue is a quadratic polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/QuasinormalModes.jl#L73-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.Serial" href="#QuasinormalModes.Serial"><code>QuasinormalModes.Serial</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Perform all AIM steps sequentially</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/QuasinormalModes.jl#L165-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.Threaded" href="#QuasinormalModes.Threaded"><code>QuasinormalModes.Threaded</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Perform all AIM steps in parallel using threads</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/QuasinormalModes.jl#L170-L172">source</a></section></article><h2 id="Public-functions"><a class="docs-heading-anchor" href="#Public-functions">Public functions</a><a id="Public-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Public-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.S0-Tuple{T} where T" href="#QuasinormalModes.S0-Tuple{T} where T"><code>QuasinormalModes.S0</code></a> — <span class="docstring-category">Method</span></header><section><div><p>All problem types must implement a S0 function. This behavior is enforced by the default implementations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/QuasinormalModes.jl#L120-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.computeDelta!-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, NumericAIMProblem{N, T}, AIMCache{N, T}, T}} where {N&lt;:Unsigned, T&lt;:Number}" href="#QuasinormalModes.computeDelta!-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, NumericAIMProblem{N, T}, AIMCache{N, T}, T}} where {N&lt;:Unsigned, T&lt;:Number}"><code>QuasinormalModes.computeDelta!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">computeDelta!(m::AIMSteppingMethod, p::NumericAIMProblem{N,T}, c::AIMCache{N,T}, ω::T) where {N &lt;: Unsigned, T &lt;: Number}</code></pre><p>Compute and return the AIM &quot;quantization condition&quot;.</p><p><strong>Input</strong></p><ul><li><code>m::AIMSteppingMethod</code>: The stepping method to use.</li><li><code>p::QuadraticEigenvalueProblem</code>: A quadratic frequency problem.</li><li><code>c::AIMCache</code>: An AIM cache object created from p.</li><li><code>ω::T</code>: Point to evaluate the quantization condition.</li></ul><p><strong>Output</strong></p><p>An object of type <code>T</code> which represents the AIM quantization condition at point ω.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/core/compute_delta.jl#L34-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.computeDelta!-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, QuadraticEigenvalueProblem{N, T}, AIMCache{N, Polynomials.Polynomial{T, X} where X}}} where {N&lt;:Unsigned, T&lt;:Number}" href="#QuasinormalModes.computeDelta!-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, QuadraticEigenvalueProblem{N, T}, AIMCache{N, Polynomials.Polynomial{T, X} where X}}} where {N&lt;:Unsigned, T&lt;:Number}"><code>QuasinormalModes.computeDelta!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">computeDelta!(p::QuadraticEigenvalueProblem{N,T}, c::AIMCache{N,Polynomial{T}}) where {N &lt;: Unsigned, T &lt;: Number}</code></pre><p>Compute and return the AIM &quot;quantization condition&quot;.</p><p><strong>Input</strong></p><ul><li><code>m::AIMSteppingMethod</code>: The stepping method to use.</li><li><code>p::QuadraticEigenvalueProblem</code>: A quadratic frequency problem.</li><li><code>c::AIMCache</code>: An AIM cache object created from p.</li></ul><p><strong>Output</strong></p><p>An object of type <code>Polynomial{T}</code> whose roots are the problem&#39;s eigenvalues.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/core/compute_delta.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.computeEigenvalues-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, NumericAIMProblem{N, T}, AIMCache{N, T}, T}} where {N&lt;:Unsigned, T&lt;:Complex}" href="#QuasinormalModes.computeEigenvalues-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, NumericAIMProblem{N, T}, AIMCache{N, T}, T}} where {N&lt;:Unsigned, T&lt;:Complex}"><code>QuasinormalModes.computeEigenvalues</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">computeEigenvalues(
    m::AIMSteppingMethod,
    p::NumericAIMProblem{N,T},
    c::AIMCache{N,T},
    guess::T;
    nls_xtol::Real = convert(T, 1.0e-10),
    nls_ftol::Real = convert(T, 1.0e-10),
    nls_iterations::Int = 1000
    ) where {N &lt;: Unsigned, T &lt;: Complex}</code></pre><p>Compute a single eigenvalue for the problem <code>p</code> with corresponding cache <code>c</code>.</p><p><strong>Input</strong></p><ul><li><code>m::AIMSteppingMethod</code>: The stepping method to use.</li><li><code>p::NumericAIMProblem</code>: The previously defined problem data.</li><li><code>c::AIMCache</code>: The cache constructed from p.</li><li><code>nls_xtol::Real</code>: Norm difference in x between two successive iterates under which convergence is declared.</li><li><code>nls_ftol::Real</code>: Infinite norm of residuals under which convergence is declared.</li><li><code>nls_iterations::Int</code>: Maximum number of iterations performed by NLsolve.</li></ul><p><strong>Output</strong></p><p>An object of type <code>SolverResults</code> returned by <code>nlsolve</code>. See <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLsolve.jl</a> for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/eigenvalue_computing/compute_eigenvalues.jl#L43-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.computeEigenvalues-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, NumericAIMProblem{N, T}, AIMCache{N, T}, T}} where {N&lt;:Unsigned, T&lt;:Real}" href="#QuasinormalModes.computeEigenvalues-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, NumericAIMProblem{N, T}, AIMCache{N, T}, T}} where {N&lt;:Unsigned, T&lt;:Real}"><code>QuasinormalModes.computeEigenvalues</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">computeEigenvalues(
    m::AIMSteppingMethod,
    p::NumericAIMProblem{N,T},
    c::AIMCache{N,T},
    guess::T;
    roots_atol::Real = 1.0e-10,
    roots_rtol::Real = 1.0e-10,
    roots_xatol::Real = 1.0e-10,
    roots_xrtol::Real = 1.0e-10,
    roots_maxevals::Int = 100
    ) where {N &lt;: Unsigned, T &lt;: Real}</code></pre><p>Compute a single eigenvalue for the problem <code>p</code> with corresponding cache <code>c</code>. For details on convergence settings see <a href="https://juliahub.com/docs/Roots/o0Xsi/1.0.7/reference/#Convergence">Roots.jl</a>.</p><p><strong>Input</strong></p><ul><li><code>m::AIMSteppingMethod</code>: The stepping method to use.</li><li><code>p::NumericAIMProblem{N,T}</code>: The previously defined problem data.</li><li><code>c::AIMCache{N,T}</code>: The cache constructed from p.</li><li><code>grid::Tuple{T,T}</code>: A tuple consisting of (start point, end point).</li><li><code>roots_atol::Real</code>: Absolute tolerance.</li><li><code>roots_rtol::Real</code>: Relative tolerance.</li><li><code>roots_xatol::Real</code>: Floating point comparison absolute tolerance.</li><li><code>roots_xrtol::Real</code>: Floating point comparison relative tolerance.</li><li><code>roots_maxevals::Int</code>: Number of algorithm iterations performed.</li></ul><p><strong>Output</strong></p><p>An object of type T containing the found eigenvalue.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/eigenvalue_computing/compute_eigenvalues.jl#L88-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.computeEigenvalues-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, QuadraticEigenvalueProblem{N, T}, AIMCache{N, Polynomials.Polynomial{T, X} where X}}} where {N&lt;:Unsigned, T&lt;:Number}" href="#QuasinormalModes.computeEigenvalues-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, QuadraticEigenvalueProblem{N, T}, AIMCache{N, Polynomials.Polynomial{T, X} where X}}} where {N&lt;:Unsigned, T&lt;:Number}"><code>QuasinormalModes.computeEigenvalues</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">computeEigenvalues(
    m::AIMSteppingMethod,
    p::QuadraticEigenvalueProblem{N,T},
    c::AIMCache{N,Polynomial{T}};
    plr_polish::Bool = true, 
    plr_epsilon::Real = convert(T, 1.0e-10)
    ) where {N &lt;: Unsigned, T &lt;: Number}</code></pre><p>Compute the eigenvalues for the problem <code>p</code> with corresponding cache <code>c</code>.</p><p><strong>Input</strong></p><ul><li><code>m::AIMSteppingMethod</code>: The stepping method to use.</li><li><code>p::QuadraticEigenvalueProblem</code>: The previously defined problem data.</li><li><code>c::AIMCache</code>: The cache constructed from p.</li><li><code>plr_polish::Bool</code>: Tell PolynomialRoots to divide the original polynomial by each root found and polish the results using the full polynomial.</li><li><code>plr_epsilon::Real</code>: The stopping criterion described in Skowron &amp; Gould paper. This is not the precision with which the roots will be calculated.</li></ul><p><strong>Output</strong></p><p>An object of type <code>Array{T,1}</code> containing the computed eigenvalues.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/eigenvalue_computing/compute_eigenvalues.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.eigenvaluesInGrid-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, NumericAIMProblem{N, T}, AIMCache{N, T}, Tuple{T, T, Int64, Int64}}} where {N&lt;:Unsigned, T&lt;:Complex}" href="#QuasinormalModes.eigenvaluesInGrid-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, NumericAIMProblem{N, T}, AIMCache{N, T}, Tuple{T, T, Int64, Int64}}} where {N&lt;:Unsigned, T&lt;:Complex}"><code>QuasinormalModes.eigenvaluesInGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eigenvaluesInGrid(
    m::AIMSteppingMethod,
    p::NumericAIMProblem{N,T},
    c::AIMCache{N,T},
    grid::Tuple{T,T,Int64,Int64};
    xtol::Real = 1.0e-10,
    ftol::Real = 1.0e-10,
    iterations::Int = 1000
    ) where {N &lt;: Unsigned, T &lt;: Complex}</code></pre><p>Attempts to find eigenvalues using a grid of complex plane data points as initial guesses passed to nlsolve.</p><p><strong>Input</strong></p><ul><li><code>m::AIMSteppingMethod</code>: The stepping method to use.</li><li><code>p::NumericAIMProblem{N,T}</code>: The previously defined problem data.</li><li><code>c::AIMCache{N,T}</code>: The cache constructed from p.</li><li><code>grid::Tuple{T,T,Int64,Int64}</code>: A tuple consisting of (start point, end point, num. of real pts., num. of imag. pots.).</li><li><code>xtol::Real</code>: Norm difference in x between two successive iterates under which convergence is declared.</li><li><code>ftol::Real</code>: Infinite norm of residuals under which convergence is declared.</li><li><code>iterations::Int</code>: Maximum number of iterations performed by NLsolve.</li></ul><p><strong>Output</strong></p><p>An object of type <code>Array{T,1}</code> containing the modes found within the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/eigenvalue_computing/eigenvalues_in_grid.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.eigenvaluesInGrid-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, NumericAIMProblem{N, T}, AIMCache{N, T}, Tuple{T, T}}} where {N&lt;:Unsigned, T&lt;:Real}" href="#QuasinormalModes.eigenvaluesInGrid-Union{Tuple{T}, Tuple{N}, Tuple{QuasinormalModes.AIMSteppingMethod, NumericAIMProblem{N, T}, AIMCache{N, T}, Tuple{T, T}}} where {N&lt;:Unsigned, T&lt;:Real}"><code>QuasinormalModes.eigenvaluesInGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eigenvaluesInGrid(
    m::AIMSteppingMethod,
    p::NumericAIMProblem{N,T},
    c::AIMCache{N,T},
    grid::Tuple{T,T};
    roots_atol::Real = 1.0e-10,
    roots_rtol::Real = 1.0e-10,
    roots_xatol::Real = 1.0e-10,
    roots_xrtol::Real = 1.0e-10,
    roots_maxevals::Int = 100
    ) where {N &lt;: Unsigned, T &lt;: Real}</code></pre><p>Attempts to find eigenvalues using a range of real data points as a search region to find_zeros. For details on convergence settings see <a href="https://juliahub.com/docs/Roots/o0Xsi/1.0.7/reference/#Convergence">Roots.jl</a>.</p><p><strong>Input</strong></p><ul><li><code>m::AIMSteppingMethod</code>: The stepping method to use.</li><li><code>p::NumericAIMProblem{N,T}</code>: The previously defined problem data.</li><li><code>c::AIMCache{N,T}</code>: The cache constructed from p.</li><li><code>grid::Tuple{T,T}</code>: A tuple consisting of (start point, end point).</li><li><code>roots_atol::Real</code>: Absolute tolerance.</li><li><code>roots_rtol::Real</code>: Relative tolerance.</li><li><code>roots_xatol::Real</code>: Floating point comparison absolute tolerance.</li><li><code>roots_xrtol::Real</code>: Floating point comparison relative tolerance.</li><li><code>roots_maxevals::Int</code>: Number of algorithm iterations performed.</li></ul><p><strong>Output</strong></p><p>An object of type <code>Array{T,1}</code> containing the eigenvalues found within the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/eigenvalue_computing/eigenvalues_in_grid.jl#L84-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.get_ODEeigen-Tuple{T} where T" href="#QuasinormalModes.get_ODEeigen-Tuple{T} where T"><code>QuasinormalModes.get_ODEeigen</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Analytic problems must implement an acessor to the eigenvalue of the ODE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/QuasinormalModes.jl#L149-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.get_ODEvar-Tuple{T} where T" href="#QuasinormalModes.get_ODEvar-Tuple{T} where T"><code>QuasinormalModes.get_ODEvar</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Analytic problems must implement an acessor to the variable of the ODE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/QuasinormalModes.jl#L142-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.get_niter-Tuple{T} where T" href="#QuasinormalModes.get_niter-Tuple{T} where T"><code>QuasinormalModes.get_niter</code></a> — <span class="docstring-category">Method</span></header><section><div><p>All problem types must implement get_niter to return the number of iterations to perform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/QuasinormalModes.jl#L128-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.get_x0-Tuple{T} where T" href="#QuasinormalModes.get_x0-Tuple{T} where T"><code>QuasinormalModes.get_x0</code></a> — <span class="docstring-category">Method</span></header><section><div><p>All problem types must implement get_x0 to return AIM&#39;s point of evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/QuasinormalModes.jl#L135-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.λ0-Tuple{T} where T" href="#QuasinormalModes.λ0-Tuple{T} where T"><code>QuasinormalModes.λ0</code></a> — <span class="docstring-category">Method</span></header><section><div><p>All problem types must implement a λ0 function. This behavior is enforced by the default implementations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/QuasinormalModes.jl#L112-L115">source</a></section></article><h2 id="Private-types"><a class="docs-heading-anchor" href="#Private-types">Private types</a><a id="Private-types-1"></a><a class="docs-heading-anchor-permalink" href="#Private-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.AIMSteppingMethod" href="#QuasinormalModes.AIMSteppingMethod"><code>QuasinormalModes.AIMSteppingMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Super-type of all stepping methods used internally by the AIM.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/QuasinormalModes.jl#L160-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.AnalyticityTrait" href="#QuasinormalModes.AnalyticityTrait"><code>QuasinormalModes.AnalyticityTrait</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Super-type of traits describing the analyticity of eigenvalue problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/QuasinormalModes.jl#L82-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.AnalyticityTrait-Tuple{Type{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:AnalyticAIMProblem}" href="#QuasinormalModes.AnalyticityTrait-Tuple{Type{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:AnalyticAIMProblem}"><code>QuasinormalModes.AnalyticityTrait</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The trait of AnalyticAIMProblem(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/QuasinormalModes.jl#L102-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.AnalyticityTrait-Tuple{Type{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:NumericAIMProblem}" href="#QuasinormalModes.AnalyticityTrait-Tuple{Type{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:NumericAIMProblem}"><code>QuasinormalModes.AnalyticityTrait</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The trait of NumericAIMProblem(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/QuasinormalModes.jl#L107-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.AnalyticityTrait-Tuple{Type{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:AIMProblem}" href="#QuasinormalModes.AnalyticityTrait-Tuple{Type{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:AIMProblem}"><code>QuasinormalModes.AnalyticityTrait</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The default trait of AIMProblem(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/QuasinormalModes.jl#L97-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.IsAnalytic" href="#QuasinormalModes.IsAnalytic"><code>QuasinormalModes.IsAnalytic</code></a> — <span class="docstring-category">Type</span></header><section><div><p>All problems with eigenvalues that <em>can</em> be described by analytic functions have this trait.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/QuasinormalModes.jl#L87-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.IsNumeric" href="#QuasinormalModes.IsNumeric"><code>QuasinormalModes.IsNumeric</code></a> — <span class="docstring-category">Type</span></header><section><div><p>All problems with eigenvalues that <em>can&#39;t</em> be described by analytic functions have this trait.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/QuasinormalModes.jl#L92-L94">source</a></section></article><h2 id="Private-functions"><a class="docs-heading-anchor" href="#Private-functions">Private functions</a><a id="Private-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Private-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.AIMStep!-Union{Tuple{U}, Tuple{T}, Tuple{N}, Tuple{Serial, AIMProblem{N, T}, AIMCache{N, U}}} where {N&lt;:Unsigned, T&lt;:Number, U}" href="#QuasinormalModes.AIMStep!-Union{Tuple{U}, Tuple{T}, Tuple{N}, Tuple{Serial, AIMProblem{N, T}, AIMCache{N, U}}} where {N&lt;:Unsigned, T&lt;:Number, U}"><code>QuasinormalModes.AIMStep!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AIMStep!(::Serial, p::AIMProblem{N,T}, c::AIMCache{N,U}) where {N &lt;: Unsigned, T &lt;: Number, U &lt;: Any}</code></pre><p>Performs a single step of the AIM algorithm sequentially:</p><ol><li>The initial data arrays are not altered.</li><li>The previous arrays receive the values of the current arrays.</li><li>The results of the next step computed using the initial and current arrays. Results are stored in the buffer arrays.</li><li>The current arrays receive the contents of the buffer arrays.</li></ol><p><strong>Input</strong></p><ul><li><code>::Serial</code>: Instance of <code>Serial</code> object.</li><li><code>p::AIMProblem</code>: The problem data to use in the computation.</li><li><code>c::AIMCache</code>: The cache of arrays that corresponds to the problem p.</li></ul><p><strong>Output</strong></p><pre><code class="nohighlight hljs">nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/core/aim_step.jl#L54-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.AIMStep!-Union{Tuple{U}, Tuple{T}, Tuple{N}, Tuple{Threaded, AIMProblem{N, T}, AIMCache{N, U}}} where {N&lt;:Unsigned, T&lt;:Number, U}" href="#QuasinormalModes.AIMStep!-Union{Tuple{U}, Tuple{T}, Tuple{N}, Tuple{Threaded, AIMProblem{N, T}, AIMCache{N, U}}} where {N&lt;:Unsigned, T&lt;:Number, U}"><code>QuasinormalModes.AIMStep!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AIMStep!(::Threaded, p::AIMProblem{N,T}, c::AIMCache{N,U}) where {N &lt;: Unsigned, T &lt;: Number, U &lt;: Any}</code></pre><p>Performs a single step of the AIM algorithm in parallel using threads:</p><ol><li>The initial data arrays are not altered.</li><li>The previous arrays receive the values of the current arrays.</li><li>The results of the next step computed using the initial and current arrays. Results are stored in the buffer arrays.</li><li>The current arrays receive the contents of the buffer arrays.</li></ol><p><strong>Input</strong></p><ul><li><code>::Threaded</code>: Instance of the <code>Threaded</code> object.</li><li><code>p::AIMProblem</code>: The problem data to use in the computation.</li><li><code>c::AIMCache</code>: The cache of arrays that corresponds to the problem p.</li></ul><p><strong>Output</strong></p><pre><code class="nohighlight hljs">nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/core/aim_step.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.computePolynomialFactors-Union{Tuple{T}, Tuple{N}, Tuple{QuadraticEigenvalueProblem{N, T}, N, Function}} where {N&lt;:Unsigned, T&lt;:Number}" href="#QuasinormalModes.computePolynomialFactors-Union{Tuple{T}, Tuple{N}, Tuple{QuadraticEigenvalueProblem{N, T}, N, Function}} where {N&lt;:Unsigned, T&lt;:Number}"><code>QuasinormalModes.computePolynomialFactors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">computePolynomialFactors(p::QuadraticEigenvalueProblem{N,T}, n::N, f::Function) where {N &lt;: Unsigned, T &lt;: Number}</code></pre><p>Create a second order <code>Polynomial</code> object in the variable <code>ω</code> by computing derivatives of <code>λ0</code> or <code>S0</code>.</p><p><strong>Input</strong></p><ul><li><code>p::QuadraticEigenvalueProblem</code>: The problem data with the expressions to compute the derivative.</li><li><code>n::Unsigned</code>: The order of the derivative.</li><li><code>f::Function</code>: the function to extract the polynomial from. Either λ0 or S0.</li></ul><p><strong>Output</strong></p><p>An object of type <code>Polynomial{T}</code> containing the polynomial resulting from the derivation of the expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/core/analytic_tools.jl#L46-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.createPoly-Union{Tuple{T}, Tuple{N}, Tuple{QuadraticEigenvalueProblem{N, T}, N, Function}} where {N&lt;:Unsigned, T&lt;:Number}" href="#QuasinormalModes.createPoly-Union{Tuple{T}, Tuple{N}, Tuple{QuadraticEigenvalueProblem{N, T}, N, Function}} where {N&lt;:Unsigned, T&lt;:Number}"><code>QuasinormalModes.createPoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">createPoly(p::QuadraticEigenvalueProblem{N,T}, n::N, f::Function)</code></pre><p>Compute the n-th coefficient of the Taylor expansion around x0 for the functions <code>λ0</code> or <code>S0</code></p><p><strong>Input</strong></p><ul><li><code>p::QuadraticEigenvalueProblem</code>: The problem data with the expressions to compute the derivative.</li><li><code>n::Unsigned</code>: The order of the derivative.</li><li><code>f::Function</code>: the function to extract the polynomial from. Either λ0 or S0.</li></ul><p><strong>Output</strong></p><p>An object of type <code>Polynomial{T}</code> containing the polynomial Taylor coefficient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/core/analytic_tools.jl#L78-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.dnx-Union{Tuple{T}, Tuple{N}, Tuple{AnalyticAIMProblem{N, T}, N, Function, Function}} where {N&lt;:Unsigned, T&lt;:Number}" href="#QuasinormalModes.dnx-Union{Tuple{T}, Tuple{N}, Tuple{AnalyticAIMProblem{N, T}, N, Function, Function}} where {N&lt;:Unsigned, T&lt;:Number}"><code>QuasinormalModes.dnx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dnx(p::AnalyticAIMProblem{N,T}, n::N, f::Function, v::Function) where {N &lt;: Unsigned, T &lt;: Number}</code></pre><p>Computes the n-th derivative of the AIM expressions with respect to ODE&#39;s variable. This function is only a thin wrapper around SymEngine&#39;s own <code>diff</code> function. It works as a barrier function that produces a type stable <code>Basic</code> result.</p><p><strong>Input</strong></p><ul><li><code>p::AnalyticAIMProblem</code>: The problem data with the expressions to compute the derivative.</li><li><code>n::Unsigned</code>: The order of the derivative.</li><li><code>f::Function</code>: The actual expression to compute the derivative. Either λ0 or S0.</li><li><code>v::Function</code>: The variable with respec to which the derivative will be computed. Either get<em>ODEvar or get</em>ODEeigen.</li></ul><p><strong>Output</strong></p><p>A <code>SymEngine.Basic</code> object with the derived expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/core/analytic_tools.jl#L26-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.dnx-Union{Tuple{T}, Tuple{T, SymEngine.Basic, SymEngine.Basic}} where T&lt;:Unsigned" href="#QuasinormalModes.dnx-Union{Tuple{T}, Tuple{T, SymEngine.Basic, SymEngine.Basic}} where T&lt;:Unsigned"><code>QuasinormalModes.dnx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dnx(n::T, f::Basic, v::Basic) where {T &lt;: Unsigned}</code></pre><p>Computes the n-th derivative of the the function f with respect to the variable v. This function re implements SymEngine&#39;s own <code>diff</code> function using an early quitting strategy.</p><p><strong>Input</strong></p><ul><li><code>n::T</code>: The order of the derivative.</li><li><code>f::Basic</code>: The expression to compute the derivative.</li><li><code>v::Basic</code>: The variable with respect to which the derivative will be computed.</li></ul><p><strong>Output</strong></p><p>A <code>SymEngine.Basic</code> object with the derived expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/core/analytic_tools.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuasinormalModes.recomputeInitials!-Union{Tuple{T}, Tuple{N}, Tuple{NumericAIMProblem{N, T}, AIMCache{N, T}, T}} where {N&lt;:Unsigned, T&lt;:Number}" href="#QuasinormalModes.recomputeInitials!-Union{Tuple{T}, Tuple{N}, Tuple{NumericAIMProblem{N, T}, AIMCache{N, T}, T}} where {N&lt;:Unsigned, T&lt;:Number}"><code>QuasinormalModes.recomputeInitials!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">recomputeInitials(p::NumericAIMProblem{N,T}, c::AIMCache{N,T}, ω::T) where {N &lt;: Unsigned, T &lt;: Number}</code></pre><p>Reevaluate (in-place) the initial data arrays. The initial data array elements are the Taylor expansion coefficients of λ0 and S0 in the ODE variable x around x0 of order get_niter(p) at a point ω.</p><p><strong>Input</strong></p><ul><li><code>p::NumericAIMProblem</code>: The problem data.</li><li><code>c::AIMCache</code>: The problem data associated cache.</li><li><code>ω::T</code>: The value of the eigenvalue to evaluate the arrays in.</li></ul><p><strong>Output</strong></p><pre><code class="nohighlight hljs">nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lucass-carneiro/QuasinormalModes.jl/blob/e92d90213df92948e61b57cc28075a002a923e4c/src/core/aim_cache.jl#L87-L100">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sho/">« Complete Example: The Harmonic Oscillator</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Wednesday 25 May 2022 18:44">Wednesday 25 May 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
